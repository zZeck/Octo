import { emulator, ajax } from "./util";
import { packOptions, unpackOptions } from "./shared";
import { editor, speedMenu, setStatusMessage } from "./index";
import { gifBuilder } from "./recording";
import { EmulatorOptions } from "./emulator";

/**
 * Sharing/Loading externally-hosted programs
 **/

const placeholderProgram = `# Chip8 is a virtual machine designed in 1977 for programming video games.
# Octo is a high level assembler, disassembler and simulator for Chip8.
# Click 'Run' and then press ASWD to move the sprite around the screen.
# Click the Octo logo for source, documentation and examples.

:alias px v1
:alias py v2

: main
  px := random 0b0011111
  py := random 0b0001111
  i  := person
  sprite px py 8

  loop
    # erase the player, update its position and then redraw:
    sprite px py 8
    v0 := OCTO_KEY_W if v0 key then py += -1
    v0 := OCTO_KEY_S if v0 key then py +=  1
    v0 := OCTO_KEY_A if v0 key then px += -1
    v0 := OCTO_KEY_D if v0 key then px +=  1
    sprite px py 8

    # lock the framerate of this program via the delay timer:
    loop
      vf := delay
      if vf != 0 then
    again
    vf := 3
    delay := vf
  again

: person
  0x70 0x70 0x20 0x70 0xA8 0x20 0x50 0x50`;

/**
 * Implementation
 **/

let lastLoadedKey: string | null = null;
//TODO change this url
const sharingBaseUrl = "https://vectorland.nfshost.com/storage/octo/";

export function share(): void {
  ajax<{ error: string; key: string }>(
    "POST",
    sharingBaseUrl,
    preparePayload(),
    (r): void => {
      // TODO unused s?
      if (r.error) {
        setStatusMessage(r.error, false);
        return;
      }
      const l = window.location.href.replace(
        /(?<link>index\.html|\?key=.*)*$/u,
        "index.html?key=" + r.key
      );
      window.location.href = l;
    }
  );
}

export function preparePayload(): {
  key: string | null;
  program: string;
  options: EmulatorOptions;
} {
  return {
    key: lastLoadedKey,
    program: editor.getValue(),
    options: packOptions(emulator)
  };
}

export function openPayload(options: EmulatorOptions, program: string): void {
  editor.setValue(program);
  speedMenu.setValue(options.tickrate);
  unpackOptions(emulator, options);
  saveLocalOptions();
  saveLocalProgram();
}

export function runPayload(options: EmulatorOptions, program: string): void {
  editor.setValue(program);
  speedMenu.setValue(options.tickrate);
  unpackOptions(emulator, options);
  document.getElementById("main-run")!.click();
}
function runShared(key: string): void {
  ajax<{ options: EmulatorOptions; program: string }>(
    "GET",
    sharingBaseUrl + key,
    null,
    (result: { options: EmulatorOptions; program: string }): void => {
      // TODO unused s?
      lastLoadedKey = key;
      runPayload(result.options, result.program);
    }
  );
}
function runGist(id: string): void {
  // TODO type result better
  ajax(
    "GET",
    "https://api.github.com/gists/" + id,
    null,
    (result: { files: { [key: string]: { content: string } } }): void => {
      // TODO unused s?
      runPayload(
        JSON.parse(result.files["options.json"].content),
        result.files["prog.ch8"].content
      );
    }
  );
}

export function saveLocalOptions(): void {
  localStorage.setItem("octoOptions", JSON.stringify(packOptions(emulator)));
}
export function saveLocalProgram(): void {
  localStorage.setItem("octoProgram", JSON.stringify(editor.getValue()));
}

window.onload = (): void => {
  // load examples
  ajax(
    "GET",
    "https://api.github.com/repos/JohnEarnest/Octo/contents/examples",
    null,
    (result: { name: string; url: string }[]): void => {
      const target = document.querySelector<HTMLElement>("#main-examples ul")!;
      target.innerHTML = "";
      result.forEach((x: { name: string; url: string }): void => {
        // TODO type x better?
        const r = document.createElement("li");
        r.innerHTML = x.name;
        r.onclick = (): void =>
          ajax(
            "GET",
            x.url,
            null,
            (clickRequestResult: { content: string }): void => {
              editor.setValue(
                window.atob(
                  clickRequestResult.content.replace(/(?:\r\n|\r|\n)/gu, "")
                )
              );
              setStatusMessage(
                "loaded example program <tt>" + x.name + "</tt>",
                true
              );
            }
          );
        target.appendChild(r);
      });
    }
  );

  // load a shared program, if specified
  const key = /key=(?<keyParam>[a-zA-Z0-9-_]+)/u.exec(location.search);
  if (key) {
    runShared(key[1]);
    return;
  }
  const gistId = /gist=(?<gistParam>\w+)/u.exec(location.search);
  if (gistId) {
    runGist(gistId[1]);
    return;
  }

  // restore the local data, if available
  try {
    const options = JSON.parse(localStorage.getItem("octoOptions")!);
    const program = JSON.parse(localStorage.getItem("octoProgram")!);
    if (options) unpackOptions(emulator, options);
    if (program && program.trim().length) {
      editor.setValue(program);
      setStatusMessage("Restored local working copy.", true);
      return;
    }
  } catch (error) {
    console.log("restoring workspace failed!");
    console.log(error);
  }

  // fall back to the demo program
  editor.setValue(placeholderProgram);
};

/**
 * Cartridges
 *
 * Octo cartridge files are GIF89a images with a payload steganographically
 * embedded in one or more animation frames. Data is stored in the least significant
 * bits of colors, 1 from the red/blue channels and 2 from the green channel,
 * allowing us to pack a hidden byte into every 2 successive pixels.
 *
 * The payload consists of a 32-bit length, followed by a sequence of ASCII bytes
 * consisting of the JSON-encoded options dictionary and source text.
 **/

const LABEL_FONT = [
  // 8x5 pixels, A-Z0-9.-
  0x3f,
  0x50,
  0x90,
  0x50,
  0x3f,
  0x00,
  0xff,
  0x91,
  0x91,
  0x91,
  0x6e,
  0x00,
  0x7e,
  0x81,
  0x81,
  0x81,
  0x42,
  0x00,
  0xff,
  0x81,
  0x81,
  0x81,
  0x7e,
  0x00,
  0xff,
  0x91,
  0x91,
  0x81,
  0x81,
  0x00,
  0xff,
  0x90,
  0x90,
  0x80,
  0x80,
  0x00,
  0x7e,
  0x81,
  0x91,
  0x91,
  0x9e,
  0x00,
  0xff,
  0x10,
  0x10,
  0x10,
  0xff,
  0x00,
  0x81,
  0x81,
  0xff,
  0x81,
  0x81,
  0x00,
  0x02,
  0x81,
  0x81,
  0xfe,
  0x80,
  0x00,
  0xff,
  0x10,
  0x20,
  0x50,
  0x8f,
  0x00,
  0xff,
  0x01,
  0x01,
  0x01,
  0x01,
  0x00,
  0xff,
  0x40,
  0x20,
  0x40,
  0xff,
  0x00,
  0xff,
  0x40,
  0x20,
  0x10,
  0xff,
  0x00,
  0x7e,
  0x81,
  0x81,
  0x81,
  0x7e,
  0x00,
  0xff,
  0x90,
  0x90,
  0x90,
  0x60,
  0x00,
  0x7e,
  0x81,
  0x85,
  0x82,
  0x7d,
  0x00,
  0xff,
  0x90,
  0x90,
  0x98,
  0x67,
  0x00,
  0x62,
  0x91,
  0x91,
  0x91,
  0x4e,
  0x00,
  0x80,
  0x80,
  0xff,
  0x80,
  0x80,
  0x00,
  0xfe,
  0x01,
  0x01,
  0x01,
  0xfe,
  0x00,
  0xfc,
  0x02,
  0x01,
  0x02,
  0xfc,
  0x00,
  0xff,
  0x02,
  0x04,
  0x02,
  0xff,
  0x00,
  0xc7,
  0x28,
  0x10,
  0x28,
  0xc7,
  0x00,
  0xc0,
  0x20,
  0x1f,
  0x20,
  0xc0,
  0x00,
  0x87,
  0x89,
  0x91,
  0xa1,
  0xc1,
  0x00,
  0x7e,
  0x81,
  0x99,
  0x81,
  0x7e,
  0x00,
  0x21,
  0x41,
  0xff,
  0x01,
  0x01,
  0x00,
  0x43,
  0x85,
  0x89,
  0x91,
  0x61,
  0x00,
  0x82,
  0x81,
  0xa1,
  0xd1,
  0x8e,
  0x00,
  0xf0,
  0x10,
  0x10,
  0xff,
  0x10,
  0x00,
  0xf2,
  0x91,
  0x91,
  0x91,
  0x9e,
  0x00,
  0x7e,
  0x91,
  0x91,
  0x91,
  0x4e,
  0x00,
  0x80,
  0x90,
  0x9f,
  0xb0,
  0xd0,
  0x00,
  0x6e,
  0x91,
  0x91,
  0x91,
  0x6e,
  0x00,
  0x62,
  0x91,
  0x91,
  0x91,
  0x7e,
  0x00,
  0x00,
  0x00,
  0x06,
  0x06,
  0x00,
  0x00,
  0x00,
  0x10,
  0x10,
  0x10,
  0x10,
  0x00
];
const BASE_IMAGE = [
  0x47,
  0x49,
  0x46,
  0x38,
  0x37,
  0x61,
  0xa0,
  0x00,
  0x80,
  0x00,
  0xa2,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x80,
  0x66,
  0x50,
  0xbf,
  0xbe,
  0xa6,
  0xf6,
  0xe3,
  0x9f,
  0xf6,
  0xea,
  0xcf,
  0xff,
  0xff,
  0xff,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x00,
  0x21,
  0xf9,
  0x04,
  0x09,
  0x00,
  0x00,
  0x06,
  0x00,
  0x2c,
  0x00,
  0x00,
  0x00,
  0x00,
  0xa0,
  0x00,
  0x80,
  0x00,
  0x00,
  0x03,
  0xff,
  0x08,
  0x1a,
  0xdc,
  0xfe,
  0x30,
  0xca,
  0x49,
  0xab,
  0xbd,
  0x38,
  0x6b,
  0xac,
  0xba,
  0x0f,
  0x42,
  0x28,
  0x8e,
  0x64,
  0x69,
  0x9e,
  0x68,
  0xaa,
  0xae,
  0x6c,
  0xeb,
  0xbe,
  0x6d,
  0xe0,
  0x75,
  0xa0,
  0xd0,
  0x91,
  0xb7,
  0x3d,
  0x87,
  0xf9,
  0xec,
  0xff,
  0xc0,
  0xa0,
  0x70,
  0x48,
  0x2c,
  0x1a,
  0x8f,
  0xc4,
  0x90,
  0xec,
  0xc3,
  0x6b,
  0x00,
  0x44,
  0x00,
  0xa7,
  0x00,
  0x62,
  0x93,
  0xc2,
  0xae,
  0xd8,
  0xac,
  0x76,
  0x7b,
  0x5a,
  0x2e,
  0xaa,
  0x20,
  0xc6,
  0x33,
  0x1a,
  0xae,
  0x4d,
  0x6b,
  0xe4,
  0xf3,
  0x18,
  0xc9,
  0x6e,
  0xbb,
  0xdf,
  0xf0,
  0xa1,
  0x92,
  0x76,
  0x16,
  0x31,
  0xea,
  0xa5,
  0x3b,
  0x7e,
  0xcf,
  0xed,
  0xfb,
  0xff,
  0x7f,
  0x4b,
  0x65,
  0x63,
  0x77,
  0x62,
  0x3a,
  0x76,
  0x35,
  0x86,
  0x69,
  0x71,
  0x8c,
  0x8d,
  0x8e,
  0x8f,
  0x3b,
  0x53,
  0x51,
  0x4a,
  0x32,
  0x7a,
  0x6a,
  0x96,
  0x98,
  0x95,
  0x66,
  0x80,
  0x9c,
  0x9d,
  0x9e,
  0x2c,
  0x99,
  0x9b,
  0x67,
  0x9b,
  0x96,
  0xa3,
  0x3c,
  0x90,
  0xa8,
  0xa9,
  0xaa,
  0x45,
  0x7c,
  0x9f,
  0xae,
  0xaf,
  0xb0,
  0x7d,
  0xa5,
  0xb1,
  0xb4,
  0xb5,
  0xb6,
  0x5d,
  0xa2,
  0xb7,
  0xba,
  0xbb,
  0xaf,
  0xb3,
  0xbc,
  0xbf,
  0xc0,
  0xb2,
  0xb9,
  0xc1,
  0xc4,
  0xc5,
  0x31,
  0xc3,
  0xc6,
  0xc9,
  0xca,
  0x23,
  0xbe,
  0xcb,
  0xce,
  0xc9,
  0xcd,
  0xab,
  0xd2,
  0xd3,
  0xd4,
  0x46,
  0x26,
  0xbe,
  0x64,
  0x1b,
  0xda,
  0xdb,
  0xdc,
  0xdd,
  0xde,
  0xdf,
  0x86,
  0x24,
  0xbe,
  0xe0,
  0xe4,
  0xe5,
  0xe6,
  0xe7,
  0x1a,
  0x79,
  0xb9,
  0x0f,
  0x03,
  0xed,
  0xee,
  0x03,
  0x0c,
  0xef,
  0xf2,
  0xf3,
  0xf4,
  0xf5,
  0xf6,
  0xf7,
  0xf8,
  0xf9,
  0xfa,
  0xfb,
  0xee,
  0x04,
  0xfe,
  0xfc,
  0xf4,
  0x1e,
  0xa8,
  0x53,
  0x17,
  0xaf,
  0x5e,
  0x00,
  0x80,
  0x08,
  0x13,
  0x2a,
  0x5c,
  0x98,
  0xcf,
  0xdf,
  0x3f,
  0x86,
  0x0e,
  0x06,
  0x8a,
  0x2b,
  0xc8,
  0xb0,
  0xa2,
  0xc5,
  0x8b,
  0x0c,
  0x1d,
  0x3e,
  0x5c,
  0xd8,
  0x40,
  0xff,
  0x22,
  0xb3,
  0x83,
  0x18,
  0x43,
  0x8a,
  0x1c,
  0x59,
  0x4f,
  0xa3,
  0xc5,
  0x71,
  0xeb,
  0x40,
  0x92,
  0x5c,
  0xc9,
  0xf2,
  0xa2,
  0xc3,
  0x93,
  0x29,
  0xd5,
  0xb5,
  0x9c,
  0x49,
  0x33,
  0xe1,
  0x4b,
  0x88,
  0x31,
  0x27,
  0xd6,
  0xdc,
  0xc9,
  0xf3,
  0xde,
  0x4d,
  0x85,
  0x28,
  0x65,
  0xf6,
  0x1c,
  0x4a,
  0x74,
  0xc0,
  0x4f,
  0x84,
  0x41,
  0x75,
  0x16,
  0x5d,
  0xca,
  0xf3,
  0xe8,
  0xbe,
  0xa4,
  0x1f,
  0x99,
  0x4a,
  0x9d,
  0x5a,
  0x92,
  0x00,
  0x54,
  0x44,
  0x54,
  0xb3,
  0x36,
  0xd5,
  0xb8,
  0xd1,
  0xdf,
  0x55,
  0x4a,
  0x5a,
  0xc3,
  0xb6,
  0xe4,
  0xea,
  0xf4,
  0xeb,
  0x19,
  0xb1,
  0x68,
  0x57,
  0x9a,
  0x9c,
  0x67,
  0x96,
  0x62,
  0xda,
  0xb7,
  0x34,
  0xdb,
  0xaa,
  0x84,
  0x4b,
  0x77,
  0xa5,
  0xdc,
  0xba,
  0x78,
  0x49,
  0xde,
  0xcd,
  0xcb,
  0xf7,
  0xe2,
  0xde,
  0xbe,
  0x80,
  0x81,
  0xe6,
  0x8c,
  0x1a,
  0xb8,
  0x30,
  0xc0,
  0xbf,
  0x86,
  0x13,
  0xdf,
  0x43,
  0xac,
  0xb8,
  0xb1,
  0x3c,
  0xc6,
  0x8e,
  0x23,
  0x43,
  0x8e,
  0xdc,
  0x78,
  0x32,
  0xe5,
  0xc4,
  0x96,
  0x2f,
  0x17,
  0xce,
  0xac,
  0x19,
  0x30,
  0xe7,
  0xce,
  0x7c,
  0x3f,
  0x83,
  0xc6,
  0x2b,
  0x7a,
  0x34,
  0xdd,
  0xd2,
  0xa6,
  0xdf,
  0xa2,
  0x4e,
  0x8d,
  0x76,
  0x35,
  0xeb,
  0xb0,
  0xae,
  0x5f,
  0x67,
  0x8d,
  0x2d,
  0x7b,
  0x2a,
  0xed,
  0xda,
  0x4c,
  0x6f,
  0xe3,
  0x2e,
  0xaa,
  0x7b,
  0xf7,
  0xd0,
  0xde,
  0xbe,
  0x79,
  0x02,
  0x0f,
  0x5e,
  0x73,
  0x38,
  0xf1,
  0x99,
  0xc6,
  0x8f,
  0xb3,
  0x4c,
  0xae,
  0x5c,
  0xef,
  0x60,
  0xac,
  0xcd,
  0xd3,
  0x32,
  0x8f,
  0x1e,
  0x72,
  0x3a,
  0x75,
  0xbf,
  0xcf,
  0xc1,
  0x5e,
  0x87,
  0x9d,
  0xfd,
  0xec,
  0x76,
  0xad,
  0xd6,
  0xbf,
  0x73,
  0xec,
  0xee,
  0x56,
  0x7c,
  0x6e,
  0xf2,
  0x73,
  0xcd,
  0x2f,
  0x0d,
  0xaf,
  0xfe,
  0x30,
  0xfa,
  0xf6,
  0x52,
  0xd9,
  0xc3,
  0xd7,
  0x27,
  0x7f,
  0x3e,
  0xbe,
  0xfa,
  0xf6,
  0xed,
  0xe1,
  0xcf,
  0x1f,
  0xf0,
  0x3d,
  0xff,
  0x9e,
  0xff,
  0xfb,
  0xfd,
  0xf7,
  0x4e,
  0x80,
  0x02,
  0xb6,
  0x43,
  0x60,
  0x81,
  0x8c,
  0xad,
  0x55,
  0x20,
  0x46,
  0x09,
  0x3a,
  0xb5,
  0x20,
  0x4e,
  0x1e,
  0x41,
  0xd7,
  0x8f,
  0x83,
  0x0f,
  0x0a,
  0x16,
  0xa1,
  0x76,
  0xef,
  0x10,
  0x50,
  0x61,
  0x75,
  0xfe,
  0xd9,
  0xb3,
  0xd1,
  0x86,
  0xee,
  0x5d,
  0xe8,
  0x9d,
  0x87,
  0x1a,
  0x82,
  0x88,
  0x14,
  0x7a,
  0xe9,
  0x35,
  0x97,
  0xe2,
  0x6f,
  0x72,
  0x95,
  0x77,
  0x9c,
  0x8b,
  0x00,
  0x76,
  0x34,
  0x11,
  0x41,
  0xe5,
  0xad,
  0x68,
  0x9a,
  0x03,
  0xe7,
  0xc9,
  0xf8,
  0x11,
  0x8d,
  0xe8,
  0xf4,
  0xe8,
  0xe3,
  0x8f,
  0xdc,
  0x88,
  0x38,
  0x0a,
  0x90,
  0x44,
  0x16,
  0x69,
  0xa4,
  0x8e,
  0x3b,
  0x3e,
  0xa3,
  0xa4,
  0x32,
  0xcd,
  0x2c,
  0xe9,
  0xa4,
  0x2e,
  0x4d,
  0x3e,
  0x29,
  0x65,
  0x2c,
  0x51,
  0x4e,
  0x69,
  0xa5,
  0x27,
  0x55,
  0x5e,
  0xa9,
  0xa5,
  0x1f,
  0x59,
  0x6e,
  0xe9,
  0x65,
  0x16,
  0x5d,
  0x7e,
  0x29,
  0xa6,
  0x0b,
  0x61,
  0x8e,
  0x69,
  0x66,
  0x0a,
  0x65,
  0x9e,
  0xa9,
  0xe6,
  0x8c,
  0x6b,
  0xb6,
  0x79,
  0x8c,
  0x9b,
  0x70,
  0xaa,
  0x90,
  0x66,
  0x9c,
  0x66,
  0xce,
  0x49,
  0xa7,
  0x98,
  0x76,
  0xde,
  0xe9,
  0x65,
  0x9e,
  0x7a,
  0x6a,
  0xc9,
  0x67,
  0x9f,
  0x56,
  0xfe,
  0x09,
  0xa8,
  0x94,
  0x82,
  0x0e,
  0xea,
  0x64,
  0xa1,
  0x86,
  0x2a,
  0x89,
  0x68,
  0xa2,
  0xce,
  0x2c,
  0xca,
  0x28,
  0x93,
  0xc8,
  0x3c,
  0xfa,
  0xa5,
  0xa3,
  0x92,
  0x16,
  0x43,
  0x69,
  0xa5,
  0xc1,
  0x5c,
  0x8a,
  0xe9,
  0x2f,
  0x9a,
  0x6e,
  0xba,
  0x4b,
  0xa7,
  0x9e,
  0xde,
  0x02,
  0x6a,
  0xa8,
  0xb5,
  0x8c,
  0x4a,
  0x2a,
  0x95,
  0x91,
  0x9e,
  0x7a,
  0x68,
  0xaa,
  0x7b,
  0x4e,
  0x00,
  0xa7,
  0xa9,
  0xbb,
  0x3c,
  0x81,
  0x82,
  0xac,
  0x6b,
  0xc2,
  0x1a,
  0x2b,
  0xad,
  0x50,
  0xe0,
  0xaa,
  0xa6,
  0xad,
  0xbc,
  0x28,
  0x70,
  0x0a,
  0x9d,
  0xbc,
  0xfe,
  0xe2,
  0xeb,
  0x9d,
  0x4b,
  0xa8,
  0xaa,
  0x65,
  0x24,
  0xc6,
  0x3e,
  0x59,
  0xcd,
  0xb2,
  0x05,
  0xcc,
  0x36,
  0xcb,
  0x46,
  0x02,
  0x00,
  0x3b
];

function unLZW(minCodeSize: number, bytes: number[]): number[] {
  const prefix: number[] = [];
  const suffix: number[] = [];
  const clear = 1 << minCodeSize;
  let size: number;
  let mask: number;
  let next: number;
  let old!: number | null;
  let first: number;
  let i = 0;
  let b = 0;
  let d = 0;
  for (let x = 0; x < clear; x++) suffix[x] = x;

  const symbol = (): number => {
    while (b < size) {
      d += bytes[i++] << b;
      b += 8;
    }
    const r = d & mask;
    d >>= size;
    b -= size;
    return r;
  };
  const cleartable = (): void => {
    size = minCodeSize + 1;
    mask = (1 << size) - 1;
    next = clear + 2;
    old = null;
  };
  const unpack = (chunk: number, r: number[]): void => {
    let c = chunk;
    const t = [];
    if (c == next) {
      t.push(first);
      c = old!;
    } // TODO safe?
    while (c > clear) {
      t.push(suffix[c]);
      c = prefix[c];
    }
    r.push((first = suffix[c]));
    Array.prototype.push.apply(r, t.reverse());
    if (next >= 4096) return;
    prefix[next] = old!;
    suffix[next++] = first;
    if ((next & mask) == 0 && next < 4096) {
      size++;
      mask += next;
    }
  };
  cleartable();
  const r = [];
  while (i < bytes.length) {
    const t = symbol();
    if (t > next! || t == clear + 1) break;
    else if (t == clear) cleartable();
    else if (old !== null) r.push(suffix[(old = first = t)]);
    else {
      unpack(t, r);
      old = t;
    }
  }
  return r;
}

function gifDecode(
  bytes: Uint8Array
): {
  width: number;
  height: number;
  frames: {
    palette: number[] | null;
    pixels: number[];
  }[];
} {
  let i = 6; // skip GIF89a
  const b = (): number => bytes[i++] || 0;
  const s = (): number => b() | (b() << 8);
  const l = (x: number): number[] => {
    const r = [];
    for (let y = 0; y < x; y++) r.push(b());
    return r;
  };
  const cl = (x: number): number[] => {
    const r = [];
    for (let y = 0; y < x; y++) r.push((b() << 16) | (b() << 8) | b());
    return r;
  };
  const dl = (): number[] => {
    let r: number[] = [];
    while (1) {
      const s1 = b();
      if (!s1) break;
      r = r.concat(l(s1));
    }
    return r;
  };

  const width = s();
  const height = s();
  const packed = b();
  s(); // background color index, pixel aspect ratio
  const gct = packed & 0x80 ? cl(1 << ((packed & 0x07) + 1)) : null;
  const frames = [];

  while (i < bytes.length) {
    const here = b();
    if (here == 0x3b) break;
    else if (here == 0x2c) {
      // const left = s(), top = s() //TODO unused?
      const iw = s();
      const ih = s();
      const ip = b();
      const lct = ip & 0x80 ? cl(1 << ((ip & 0x70) + 1)) : null;
      if (ip & 0x40) throw Error("interlaced GIFs are not supported");
      if (iw != width || ih != height) throw Error("windowing is nyi!");
      frames.push({ palette: lct || gct, pixels: unLZW(b(), dl()) });
    } else if (here == 0x21) {
      const xt = b();
      if (xt in { 0x01: 1, 0xf9: 1, 0xfe: 1, 0xff: 1 }) {
        dl();
      } // text, gce, comment, app
      else {
        throw Error(`unrecognized extension type ${xt}!`);
      }
    } else {
      throw Error(`unrecognized block type ${here}!`);
    }
  }
  return { width, height, frames };
}

function printLabel(
  dest: { w: number; h: number; buffer: Uint8Array },
  pen: number,
  text: string
): void {
  const alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-";
  let cursorx = 16;
  let cursory = 32;
  text
    .toUpperCase()
    .replace(/[^A-Z0-9-.\n ]/gu, ".")
    .split("")
    .forEach((c: string): void => {
      if (c == " ") {
        cursorx += 6;
      } else if (c == "\n") {
        cursorx = 16;
        cursory += 9;
      } else {
        const i = alpha.indexOf(c);
        for (let x = 0; x < 6; x++) {
          for (let y = 0; y < 8; y++) {
            if (x + cursorx > dest.w - 16 || y + cursory > dest.h) continue;
            if (Math.random() > 0.95) continue;
            const color = (LABEL_FONT[i * 6 + x] >> (7 - y)) & 1;
            if (!color) continue;
            dest.buffer[x + cursorx + dest.w * (y + cursory)] = pen;
          }
        }
        cursorx += 6;
      }
      cursorx += Math.random() > 0.8 ? 1 : 0;
      cursory += Math.random() > 0.8 ? 1 : 0;
    });
}

export function buildCartridge(
  label: string,
  data: {
    key: null | string;
    options: EmulatorOptions;
    program: string;
  }
): number[] {
  const base = gifDecode(new Uint8Array(BASE_IMAGE)); // TODO correct construct?
  const bytes = JSON.stringify(data)
    .split("")
    .map((x: string): number => x.charCodeAt(0));
  const payload = [
    (bytes.length >> 24) & 0xff,
    (bytes.length >> 16) & 0xff,
    (bytes.length >> 8) & 0xff,
    bytes.length & 0xff
  ].concat(bytes);
  const w = base.width;
  const h = base.height;
  const PER_FRAME = (w * h) / 2;
  const expand = (colors: number[]): number[] => {
    const r: number[] = [];
    colors.forEach((c: number): void => {
      for (let x = 0; x < 16; x++)
        r.push((c & 0xfefcfe) | ((x & 0x8) << 13) | ((x & 0x6) << 7) | (x & 1));
    });
    return r;
  };
  const encode = (buffer: Uint8Array, dataArray: number[]): Uint8Array => {
    if (dataArray.length > buffer.length / 2) throw Error("data overflow!");
    return buffer.map(
      (x, i): number =>
        x * 16 +
        (((dataArray[Math.floor(i / 2)] || 0) >> (i % 2 == 0 ? 4 : 0)) & 0xf)
    );
  };
  const g = gifBuilder(w, h, expand(base.frames[0].palette!));
  for (let x = 0; x < payload.length; x += PER_FRAME) {
    const p = { w: w, h: h, buffer: new Uint8Array(base.frames[0].pixels) };
    printLabel(p, 1, label);
    g.frame(encode(p.buffer, payload.slice(x, x + PER_FRAME)));
  }
  return g.finish();
}

export function parseCartridge(
  image: Uint8Array
): { options: EmulatorOptions; program: string } {
  const parts = gifDecode(image);
  const nybble = (x: number): number =>
    ((x >> 13) & 8) | ((x >> 7) & 6) | (x & 1);
  const byte = (f: number, i: number): number =>
    (nybble(parts.frames[f].palette![parts.frames[f].pixels[i]]) << 4) |
    nybble(parts.frames[f].palette![parts.frames[f].pixels[i + 1]]);
  const size =
    (byte(0, 0) << 24) | (byte(0, 2) << 16) | (byte(0, 4) << 8) | byte(0, 6);
  let json = "";
  for (let x = 0, i = 8, f = 0; x < size; x++) {
    json += String.fromCharCode(byte(f, i));
    i += 2;
    if (i >= parts.frames[f].pixels.length) {
      f++;
      i = 0;
    }
  }
  return JSON.parse(json);
}
